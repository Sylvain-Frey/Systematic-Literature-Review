id,year,author,title,abstract,library,search_term,url
09-Kraus-Multi-core,2009,"Johann M. Kraus, Hans A. Kestler",Multi-core parallelization in Clojure: a case study,"In recent years, the demand for computational power in data mining applications has increased due to rapidly growing data sets. As a consequence, standard algorithms need to be parallelized for fast processing of the generated data sets. Unfortunately, most approaches for parallelizing algorithms require a careful software design and a deep knowledge about thread-safe programming. As a consequence they are hardly applicable for rapid prototyping of new algorithms. We outline the process of multi-core parallelization using Clojure, a new functional programming language utilizing the Java Virtual Machine (JVM) that does not require knowledge of thread-safe programming. We provide some benchmark results for our multi-core algorithm to demonstrate its computational power. The rationale behind Clojure is combining the industry-standard JVM with functional programming, immutable data structures, and a built-in concurrency support via software transactional memory. This makes it a suitable tool for parallelization and rapid prototyping in many areas. In this case study we present a multi-core parallel implementation of the k-means cluster algorithm. The multi-core algorithm shows an increase in computation speed up to a factor of 10 compared to R or network based parallelization.",ELW '09: Proceedings of the 6th European Lisp Workshop,clojure,http://dl.acm.org/ft_gateway.cfm?id=1562870&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-Dhiman-Clojure:,2013,"Karan Dhiman, Maxim Mai, Jay Soni, Kyle Lam, Sang-Ah Han","Clojure: modular programming with functional, concurrent language on the JVM","Clojure: Modular Programming with Functional, Concurrent Language on the JVM The complexity of software demands well structured architecture. Structure in software in quintessential for writing good code which is easy to debug and extend. Well structured ...",CASCON '13: Proceedings of the 2013 Conference of the Center for Advanced Studies on Collaborative Research,clojure,
10-Bedra-Clojure,2010,Aaron Bedra,Clojure Tutorial,In this tutorial you will spend some time learning about what clojure has to offer and build an application that solves a real world problem. In this tutorial pair programming is welcome and encouraged! Bring a friend to help you work through the exercises ...,CUFP '10: SIGPLAN Commercial Users of Functional Programming,clojure,
08-Hickey-The,2008,Rich Hickey,The Clojure programming language,"Customers and stakeholders have substantial investments in, and are comfortable with the performance, security and stability of, industry-standard platforms like the JVM and CLR. While Java and C# developers on those platforms may envy the succinctness, ...",DLS '08: Proceedings of the 2008 symposium on Dynamic languages,clojure,
10-Fogus-Naïveté,2010,Michael Fogus,"Naïveté vs. experience: or, how we thought we could use Scala and Clojure, and how we actually did","This talk will discuss the use of Scala and Clojure in an ongoing software project, now 2-years old. The talk will start with an anecdote about how each language was pitched to the software team composed of programmers with very little to no prior experience with functional programming. The actual Scala pitch will be dissected and criticized and then distilled into a few general thoughts on how to make an effective functional language pitch. With these tangential matters out of the way, a description of the difficulties ramping up to the full use of Scala will be discussed, followed by a simplified description of the system developed. The talk will briefly cover the conceptual hurdles that the team experienced when changing from a purely object-oriented mindset to a more functional approach. Additionally, the talk will focus on how Clojure was used for ancillary functionality and tooling. The difficulties experienced, both technical and cultural, in introducing Clojure into the mainline source will then be covered. To wind down, the advantages and disadvantages, both real and perceived, between the use of both languages in a commercial setting will be explored. Finally, the lessons learned after 2 years will be contrasted with the initial pitch to see where experience and naïveté intersected.",CUFP '10: SIGPLAN Commercial Users of Functional Programming,clojure,http://dl.acm.org/ft_gateway.cfm?id=1900172&type=mov&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-Li-JVM-hosted,2013,"Wing Hang Li, David R. White, Jeremy Singer","JVM-hosted languages: they talk the talk, but do they walk the walk?","The rapid adoption of non-Java JVM languages is impressive: major international corporations are staking critical parts of their software infrastructure on components built from languages such as Scala and Clojure. However with the possible exception of Scala, there has been little academic consideration and characterization of these languages to date. In this paper, we examine four non-Java JVM languages and use exploratory data analysis techniques to investigate differences in their dynamic behavior compared to Java. We analyse a variety of programs and levels of behavior to draw distinctions between the different programming languages. We briefly discuss the implications of our findings for improving the performance of JIT compilation and garbage collection on the JVM platform.","PPPJ '13: Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools",clojure,http://dl.acm.org/ft_gateway.cfm?id=2500838&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
12-Kovanovic-Highway:,2012,"Vitomir Kovanovic, Dragan Djuric",Highway: a domain specific language for enterprise application integration,"Highway is a domain-specific language for implementing enterprise application integration solutions in a technology independent and functional manner. As an internal DSL developed on top of Clojure programming language, Highway uses functional programming techniques in order to simplify enterprise application integration development. In this paper we focus on abstractions and language constructs that define Highway's approach to integration. We also cover implementation of enterprise integration patterns using Highway since they represent various common situations in enterprise application integration development.",ISEC '12: Proceedings of the 5th India Software Engineering Conference,clojure,http://dl.acm.org/ft_gateway.cfm?id=2134259&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
12-Yeboah-Antwi-Evolving,2012,Kwaku Yeboah-Antwi,Evolving software applications using genetic programming -- PushCalc: the evolved calculator,"This paper describes PushCalc, a system that evolves a Calculator, a complete software application. PushCalc is a modified version of Clojush, the clojure implementation of the PushGP genetic programming system1. PushCalc supports the definition and storage of names and functions via its naming mechanism, tags. The goal of this system is to utilise this ability to evolve an individual that can create the modular parts of the calculator and also know when and in what situations to use which modular functions and perform the correct operations depending on the input given to the system.",GECCO Companion '12: Proceedings of the fourteenth international conference on Genetic and evolutionary computation conference companion,clojure,http://dl.acm.org/ft_gateway.cfm?id=2330875&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-Roemers-An,2013,"Arnout Roemers, Kardelen Hatun, Christoph Bockisch","An adapter-aware, non-intrusive dependency injection framework for Java","In strongly typed Object-Oriented Programming languages, it is common to encounter type incompatibilities between separately developed software components one desires to compose. Using the Adapter pattern to overcome these type incompatibilities is only an option if changing the source code of the software components is feasible, as references from objects to other objects are oftentimes hard-coded. The concept of Dependency Injection (DI) is aimed at mitigating the issue of hard-coded references. However, current implementations of DI are intrusive in ways that component developers need to foresee future use cases. To increase the reusability of components we propose an approach and a tool to configure interoperations between components externally, without the need for intrusive code changes. This approach is based on a new dependency injection mechanism that is combined with the Adapter pattern. If necessary, the most appropriate adapter to inject is selected automatically, thereby making the specifications of dependency injection very flexible.","PPPJ '13: Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools",clojure,http://dl.acm.org/ft_gateway.cfm?id=2500834&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Rytz-Named,2010,"Lukas Rytz, Martin Odersky",Named and default arguments for polymorphic object-oriented languages: a discussion on the design implemented in the Scala language,This article describes the design and implementation of named and default arguments in the Scala programming language. While these features are available in many other languages there are significant differences in the actual implementations. We present a design that unifies the most reasonable properties for an object-oriented language and provides new possibilities by allowing default arguments on generic and implicit parameters. We also present a solution for the problem of writing a lightweight generic update function for algebraic datatypes.,SAC '10: Proceedings of the 2010 ACM Symposium on Applied Computing,clojure,http://dl.acm.org/ft_gateway.cfm?id=1774529&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
09-Rose-Bytecodes,2009,John R. Rose,Bytecodes meet combinators: invokedynamic on the JVM,"The Java Virtual Machine (JVM) has been widely adopted in part because of its classfile format, which is portable, compact, modular, verifiable, and reasonably easy to work with. However, it was designed for just one language---Java---and so when it is used to express programs in other source languages, there are often ""pain points"" which retard both development and execution. The most salient pain points show up at a familiar place, the method call site. To generalize method calls on the JVM, the JSR 292 Expert Group has designed a new invokedynamic instruction that provides user-defined call site semantics. In the chosen design, invokedynamic serves as a hinge-point between two coexisting kinds of intermediate language: bytecode containing dynamic call sites, and combinator graphs specifying call targets. A dynamic compiler can traverse both representations simultaneously, producing optimized machine code which is the seamless union of both kinds of input. As a final twist, the user-defined linkage of a call site may change, allowing the code to adapt as the application evolves over time. The result is a system balancing the conciseness of bytecode with the dynamic flexibility of function pointers.",VMIL '09: Proceedings of the Third Workshop on Virtual Machines and Intermediate Languages,clojure,http://dl.acm.org/ft_gateway.cfm?id=1711508&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Brown-Strategies,2010,"Richard Brown, Elizabeth Shoop, Joel Adams, Curtis Clifton, Mark Gardner, Michael Haupt, Peter Hinsbeeck",Strategies for preparing computer science students for the multicore world,"Multicore computers have become standard, and the number of cores per computer is rising rapidly. How does the new demand for understanding of parallel computing impact computer science education? In this paper, we examine several aspects of this question: (i) What parallelism body of knowledge do todayâ€™s students need to learn? (ii) How might these concepts and practices be incorporated into the computer science curriculum? (iii) What resources will support computer science educators, including non-specialists, to teach parallel computing? (iv) What systemic obstacles impede this change, and how might they be overcome? We address these concerns as an initial framework for responding to the urgent challenge of injecting parallelism into computer science curricula",ITiCSE-WGR '10: Proceedings of the 2010 ITiCSE working group reports,clojure,http://dl.acm.org/ft_gateway.cfm?id=1971689&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Yamamiya-Tamacola,2010,"Takashi Yamamiya, Yoshiki Ohshima",Tamacola --- a meta language kit for the web: a report on creating a self-hosting lisp compiler on the Tamarin VM,"Tamacola is a dynamic, self-sustaining meta-language system grounded upon the Tamarin VM. Tamacola compiles a Scheme-like S-expression language into ActionScript bytecodes, and contains meta-linguistic features, such as a PEG parser generator and macro system, which make it useful for defining new languages. In fact, Tamacola is written in itself, using its meta-linguistic features. Since the Tamarin VM can load ActionScript bytecode files to extend and replace running programs, Tamacola can extend itself and define new languages while it is running. Furthermore, since the Tamarin VM is part of the ubiquitous Adobe Flash player, this self-modification can be accomplished while running in a web browser, with no extra installation requirement. Objects in Tamacola are intimately tied to their Action-Script counterparts, providing good interoperability between Tamacola and the Flash Player. To show that the system is ready for practical use, we used Tamacola to implement both an interactive programming environment (""Workspace"") and a simple particle language.",S3 '10: Workshop on Self-Sustaining Systems,clojure,http://dl.acm.org/ft_gateway.cfm?id=1942799&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
11-Nyblom-Erlang,2011,Patrik Nyblom,Erlang ETS tables and software transactional memory: how transactions make ETS tables more like ordinary actors,"This article describes a way to make the ETS tables of Erlang fit better into the actor programming model. Enhancing the interface of the ETS tables with a concept of transactions is suggested as a means both to achieve increased parallelism, better performance and less error-prone code, while still keeping no less true to the actor model.",Erlang '11: Proceedings of the 10th ACM SIGPLAN workshop on Erlang,clojure,http://dl.acm.org/ft_gateway.cfm?id=2034658&type=mp4&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
"13-Ponge-Golo,",2013,"Julien Ponge, Frédéric Le Mouël, Nicolas Stouls","Golo, a dynamic, light and efficient language for post-invokedynamic JVM","This paper introduces Golo, a simple dynamic programming language for the Java Virtual Machine (JVM) that has been designed to leverage the capabilities of the new Java 7 invokedynamic instruction and API (JSR 292). Golo has its own language constructs being designed with invokedynamic in mind, whereas existing dynamic languages for the JVM such as Groovy, JRuby or Nashorn have to adapt language constructions which are sometimes hard to optimize. Coupled with a minimal runtime that directly uses the Java SE API, Golo is an interesting language for rapid prototyping, polyglot application embedding, research (e.g., runtime extensions, language prototyping) and teaching (e.g., programming, dynamic language runtime implementation). We show that the language design around invokedynamic allows for a very concise runtime code base with performance figures that compare favorably against Java and other dynamic JVM languages. We also discuss its future directions, either as part of Golo or through language and runtime research extensions.","PPPJ '13: Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools",clojure,http://dl.acm.org/ft_gateway.cfm?id=2500844&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-McCabe-Feel,2013,"Frank McCabe, Michael Sperber",Feel different on the Java platform: the star programming language,"Star is a functional, multi-paradigm and extensible programming language that runs on the Java platform. Starview Inc. developed the language as an integral part of the Starview Enterprise Platform, a framework for real-time business applications such as factory scheduling and data analytics. Star borrows from many languages, with obvious heritage from Haskell, ML, and April, but also contains new approaches to some design aspects, such as syntax and syntactic extensibility, actors, and queries. Its texture is quite different from that of other languages on the Java platform. Despite this, the learning curve for Java programmers is surprisingly shallow. The combination of a powerful type system (which includes type inference, constrained polymorphism, and existentials) and syntactic extensibility make the Star well-suited to producing embedded domain-specific languages. This paper gives an overview of the language, and reports on some aspects of its design process, on our experience on using it in industrial projects, and on our experience implementing Star on the Java platform.","PPPJ '13: Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools",clojure,http://dl.acm.org/ft_gateway.cfm?id=2500837&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
09-Costanza-Context-oriented,2009,"Pascal Costanza, Charlotte Herzeel, Theo D'Hondt",Context-oriented software transactional memory in common lisp,"Software transactional memory (STM) is a promising approach for coordinating concurrent threads, for which many implementation strategies are currently being researched. Although some first steps exist to ease experimenting with different strategies, this still remains a relatively complex and cumbersome task. The reason is that software transactions require STM-specific dynamic crosscutting adaptations, but this is not accounted for in current STM implementations. This paper presents CSTM, an STM framework based on Context-oriented Progamming, in which transactions are modelled as dynamically scoped layer activations. It enables expressing transactional variable accesses as user-defined crosscutting concerns, without requiring invasive changes in the rest of a program. This paper presents a proof-of-concept implementation based on ContextL for Common Lisp, along with example STM strategies and preliminary benchmarks, and introduces some of ContextL's unique features for context-dependent variable accesses.",DLS '09: Proceedings of the 5th symposium on Dynamic languages,clojure,http://dl.acm.org/ft_gateway.cfm?id=1640144&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
09-Bloom-Thorn:,2009,"Bard Bloom, John Field, Nathaniel Nystrom, Johan Östlund, Gregor Richards, Rok Strniša, Jan Vitek, Tobias Wrigstad","Thorn: robust, concurrent, extensible scripting on the JVM","Scripting languages enjoy great popularity due to their support for rapid and exploratory development. They typically have lightweight syntax, weak data privacy, dynamic typing, powerful aggregate data types, and allow execution of the completed parts of incomplete programs. The price of these features comes later in the software life cycle. Scripts are hard to evolve and compose, and often slow. An additional weakness of most scripting languages is lack of support for concurrency - though concurrency is required for scalability and interacting with remote services. This paper reports on the design and implementation of Thorn, a novel programming language targeting the JVM. Our principal contributions are a careful selection of features that support the evolution of scripts into industrial grade programs - e.g., an expressive module system, an optional type annotation facility for declarations, and support for concurrency based on message passing between lightweight, isolated processes. On the implementation side, Thorn has been designed to accommodate the evolution of the language itself through a compiler plugin mechanism and target the Java virtual machine.",OOPSLA '09: Proceeding of the 24th ACM SIGPLAN conference on Object oriented programming systems languages and applications,clojure,http://dl.acm.org/ft_gateway.cfm?id=1640098&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Kaewkasi-Towards,2010,Chanwit Kaewkasi,Towards performance measurements for the Java Virtual Machine's invokedynamic,"This paper presents a study of a Java Virtual Machine prototype from the Da Vinci Machine project, defined by JSR 292. It describes binary translation techniques to prepare benchmarks to run on the invokedynamic mode of the prototype, resulting in the invokedynamic version of the SciMark 2.0 suite. Benchmark preparation techniques presented in this paper are proven to be useful as the invokedynamic version of benchmark programs successfully identified strange slowness behavior of the invokedynamic mode of the server virtual machine. Surprisingly, benchmarking results show that the invoke-dynamic mode with direct method handles on the server virtual machine is just 2-5 times slower than native Java invocations, except the Monte Carlo benchmark. But this mode on the client virtual machine still requires further performance tuning.",VMIL '10: Virtual Machines and Intermediate Languages,clojure,http://dl.acm.org/ft_gateway.cfm?id=1941057&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
11-Frantz-Augmenting,2011,"Christopher Frantz, Mariusz Nowostawski, Martin K. Purvis",Augmenting android with AOSE principles for enhanced functionality reuse in mobile applications,"The Android platform has popularized and caused a widespread adoption of its application development approach based on loosely coupled application components. This loose coupling allows for a flexible composition of applications but also enables invocations and reuse of individual components from third-party applications. One problem with the original Android design is that the rather coarse-grained application components themselves prohibit more fine-grained decomposition. To provide more flexible loosely coupled components and also to foster the reuse of more elementary fine-grained functionality, we suggest the extension of Android application components with our concept of $#956;-agents. Moreover, the organisational aspects of the $#956;-agent model introduce means to structure functionality in a more systematic manner. In this article, we introduce our platform concept called Micro-agents on Android (MOA) that realizes the integration of application development principles with a lightweight notion of agency. Several scenarios are used to describe the benefit from functionality reuse across applications enabled by MOA. A performance evaluation demonstrates that $#956;-agents interact in a more efficient manner than Android services, making them well-suited for fine-grained decomposition. Our approach serves as an example showing how existing technology can benefit from utilizing the modelling advantages of agent-based technologies.",AAMAS'11: Proceedings of the 10th international conference on Advanced Agent Technology,clojure,http://dl.acm.org/ft_gateway.cfm?id=2183440&type=external&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Pestov-Factor:,2010,"Sviatoslav Pestov, Daniel Ehrenberg, Joe Groff",Factor: a dynamic stack-based programming language,"Factor is a new dynamic object-oriented programming language. It began as an embedded scripting language and evolved to a mature application development language. The language has a simple execution model and is based on the manipulation of data on a stack. An advanced metaprogramming system provides means for easily extending the language. Thus, Factor allows programmers to use the right features for their problem domain. The Factor implementation is self-hosting, featuring an interactive development environment and an optimizing compiler. In this paper, the language and its implementation are presented.",DLS '10: Proceedings of the 6th symposium on Dynamic languages,clojure,http://dl.acm.org/ft_gateway.cfm?id=1869637&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
11-Marr-Which,2011,"Stefan Marr, Mattias De Wael, Michael Haupt, Theo D'Hondt",Which problems does a multi-language virtual machine need to solve in the multicore/manycore era?,"While parallel programming for very regular problems has been used in the scientific community by non-computer-scientists successfully for a few decades now, concurrent programming and solving irregular problems remains hard. Furthermore, we shift from few expert system programmers mastering concurrency for a constrained set of problems to mainstream application developers being required to master concurrency for a wide variety of problems. Consequently, high-level language virtual machine (VM) research faces interesting questions. What are processor design changes that have an impact on the abstractions provided by VMs to provide platform independence? How can application programmers' diverse needs be facilitated to solve concurrent programming problems? We argue that VMs will need to be ready for a wide range of different concurrency models that allow solving concurrency problems with appropriate abstractions. Furthermore, they need to abstract from heterogeneous processor architectures, varying performance characteristics, need to account for memory access cost and inter-core communication mechanisms but should only expose the minimal useful set of notions like locality, explicit communication, and adaptable scheduling to maintain their abstracting nature. Eventually, language designers need to be enabled to guarantee properties like encapsulation, scheduling guarantees, and immutability also when an interaction between different problem-specific concurrency abstractions is required.","SPLASH '11 Workshops: Proceedings of the compilation of the co-located workshops on DSM'11, TMC'11, AGERE!'11, AOOPES'11, NEAT'11, & VMIL'11",clojure,http://dl.acm.org/ft_gateway.cfm?id=2095104&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
"11-Pye-Locks,",2011,Ian Pye,"Locks, deadlocks and abstractions: experiences with multi-threaded programming at CloudFlare, Inc.",An abstract is not available.,"SPLASH '11 Workshops: Proceedings of the compilation of the co-located workshops on DSM'11, TMC'11, AGERE!'11, AOOPES'11, NEAT'11, & VMIL'11",clojure,http://dl.acm.org/ft_gateway.cfm?id=2095073&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
11-Chew-MusEEGk:,2011,"Yee Chieh (Denise) Chew, Eric Caspary",MusEEGk: design of a BCMI,"We present a novel integration of a brain-computer interface (BCI) with a music step sequencer. Previous BCIs that utilize EEG data to form music provide users little control over the final composition or do not provide enough feedback. Our interface allows a user to create and modify a melody in real time and provides continuous aural and visual feedback to the user, thus affording a controllable means to achieve creative expression.",C&C '11: Proceedings of the 8th ACM conference on Creativity and cognition,clojure,http://dl.acm.org/ft_gateway.cfm?id=2069679&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Noël-Extensible,2010,Cyprien Noël,Extensible software transactional memory,"XSTM is a software transactional memory that can be extended by pluggable components. Extensions can access transactions read and write sets through an API, and process them e.g., for logging, change notification, state persistence or replication. This project explores ways to make memory transactions useful beyond thread synchronization. We describe in particular an application architecture enabled by extensions which aims to combine some of the strengths of shared state and of the Actor model. Shared state offers developers the modeling power of object orientation, and avoids the overhead of copying memory between components. The Actor model offers safety and composability when writing parallel and distributed applications. Our second design goal is to make memory transactions easy to reason about and safe to use. Opacity is achieved using a Multi Version Concurrency Control design where transactions are view-isolated, i.e., run in stable and consistent snapshots of the full memory. Transactions never encounter inconsistent data, do not abort while partially executed, and global progress is guaranteed. The programming model is further simplified by enforcing strong atomicity at the type system level, as transactional objects accessors require an ambient transaction. Finally, our design offers interesting performance characteristics by avoiding mutable shared state. Data is either mutable but private to a thread, or shared but immutable. This allows transactions to run without synchronization (no memory fence) between start and commit, which are themselves implemented in a lock-free way using O(1) memory fences and compare-and-swaps. We describe working implementations on the JVM and CLR for the STM and some extensions.",C3S2E '10: Proceedings of the Third C* Conference on Computer Science and Software Engineering,clojure,http://dl.acm.org/ft_gateway.cfm?id=1822331&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
11-Ricci-Designing,2011,"Alessandro Ricci, Andrea Santi",Designing a general-purpose programming language based on agent-oriented abstractions: the simpAL project,"The fundamental turn of software toward concurrency, decentralization, distribution, interaction calls for conceptually extending or evolving mainstream programming paradigms with proper high-level features to tackle these aspects. To this purpose, in this paper we discuss the value of agent-oriented programming as a general-purpose programming paradigm to tackle this challenge, and, in particular, we present an agent-oriented programming language called simpAL, which is based on agent-oriented abstractions that are meant to simplify the programming of modern applications.","SPLASH '11 Workshops: Proceedings of the compilation of the co-located workshops on DSM'11, TMC'11, AGERE!'11, AOOPES'11, NEAT'11, & VMIL'11",clojure,http://dl.acm.org/ft_gateway.cfm?id=2095078&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Eide-PLOS,2010,"Eric Eide, Gilles Muller, Olaf Spinczyk",PLOS 2009: fifth workshop on programming languages and operating systems,"This report summarizes the Fifth Workshop on Programming Languages and Operating Systems (PLOS 2009), which was held in conjunction with the SOSP 2009 conference. This report presents the motivation for holding the workshop and summarizes the workshop contributions.","SIGOPS Operating Systems Review , Volume 43 Issue 4",clojure,http://dl.acm.org/ft_gateway.cfm?id=1713262&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
11-Ahmad-The,2011,"Salman Ahmad, Alexis Battle, Zahan Malkani, Sepander Kamvar",The jabberwocky programming environment for structured social computing,"We present Jabberwocky, a social computing stack that consists of three components: a human and machine resource management system called Dormouse, a parallel programming framework for human and machine computation called ManReduce, and a high-level programming language on top of ManReduce called Dog. Dormouse is designed to enable cross-platform programming languages for social computation, so, for example, programs written for Mechanical Turk can also run on other crowdsourcing platforms. Dormouse also enables a programmer to easily combine crowdsourcing platforms or create new ones. Further, machines and people are both first-class citizens in Dormouse, allowing for natural parallelization and control flows for a broad range of data-intensive applications. And finally and importantly, Dormouse includes notions of real identity, heterogeneity, and social structure. We show that the unique properties of Dormouse enable elegant programming models for complex and useful problems, and we propose two such frameworks. ManReduce is a framework for combining human and machine computation into an intuitive parallel data flow that goes beyond existing frameworks in several important ways, such as enabling functions on arbitrary communication graphs between human and machine clusters. And Dog is a high-level procedural language written on top of ManReduce that focuses on expressivity and reuse. We explore two applications written in Dog: bootstrapping product recommendations without purchase data, and expert labeling of medical images.",UIST '11: Proceedings of the 24th annual ACM symposium on User interface software and technology,clojure,http://dl.acm.org/ft_gateway.cfm?id=2047203&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-Stadler-An,2013,"Lukas Stadler, Gilles Duboscq, Hanspeter Mössenböck, Thomas Würthinger, Doug Simon",An experimental study of the influence of dynamic compiler optimizations on Scala performance,"Java Virtual Machines are optimized for performing well on traditional Java benchmarks, which consist almost exclusively of code generated by the Java source compiler (javac). Code generated by compilers for other languages has not received nearly as much attention, which results in performance problems for those languages. One important specimen of ""another language"" is Scala, whose syntax and features encourage a programming style that differs significantly from traditional Java code. It suffers from the same problem -- its code patterns are not optimized as well as the ones originating from Java code. JVM developers need to be aware of the differences between Java and Scala code, so that both types of code can be executed with optimal performance. This paper presents a detailed investigation of the performance impact of a large number of optimizations on the Scala DaCapo and the Java DaCapo benchmark suites. It describes the optimization techniques and analyzes the differences between traditional Java applications and Scala applications. The results help compiler engineers in understanding the characteristics of Scala. We performed these experiments on the work-in-progress Graal compiler. Graal is a new dynamic compiler for the HotSpot VM which aims to work well for a diverse set of workloads, including languages other than Java.",SCALA '13: Proceedings of the 4th Workshop on Scala,clojure,http://dl.acm.org/ft_gateway.cfm?id=2489846&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
10-Terei-An,2010,"David A. Terei, Manuel M.T. Chakravarty",An llVM backend for GHC,"In the presence of ever-changing computer architectures, high-quality optimising compiler backends are moving targets that require specialist knowledge and sophisticated algorithms. In this paper, we explore a new backend for the Glasgow Haskell Compiler (GHC) that leverages the Low Level Virtual Machine (LLVM), a new breed of compiler written explicitly for use by other compiler writers, not high-level programmers, that promises to enable outsourcing of low-level and architecture-dependent aspects of code generation. We discuss the conceptual challenges and our backend design. We also provide an extensive quantitative evaluation of the performance of the backend and of the code it produces.",Haskell '10: Proceedings of the third ACM Haskell symposium on Haskell,clojure,http://dl.acm.org/ft_gateway.cfm?id=1863538&type=mov&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-Martinez-Just,2013,"Bruno Martinez, Marcos Viera, Alberto Pardo",Just do it while compiling!: fast extensible records in haskell,"The library for strongly typed heterogeneous collections HList provides an implementation of extensible records in Haskell that needs only a few common extensions of the language. In HList, records are represented as linked lists of label-value pairs with a lookup operation that is linear-time in the number of fields. In this paper, we use type-level programming techniques to develop a more efficient representation of extensible records for HList. We propose two internal encodings for extensible records that improve lookup at runtime without needing a total order on the labels. One of the encodings performs lookup in constant time but at a cost of linear time insertion. The other one performs lookup in logarithmic time while preserving the fast insertion of simple linked lists. Through staged compilation, the required slow search for a field is moved to compile time in both cases.",PEPM '13: Proceedings of the ACM SIGPLAN 2013 workshop on Partial evaluation and program manipulation,clojure,http://dl.acm.org/ft_gateway.cfm?id=2426908&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
13-Merrifield-Conversion:,2013,"Timothy Merrifield, Jakob Eriksson",Conversion: multi-version concurrency control for main memory segments,"We present Conversion, a multi-version concurrency control system for main memory segments. Like the familiar Subversion version control system for files, Conversion provides isolation between processes that each operate on their own working copy. A process retrieves and merges any changes committed to the trunk by calling update(), and a call to commit() pushes any local changes to the trunk. Conversion operations are fast, starting at a few microseconds and growing linearly (by less than 1 μs) with the number of modified pages. This is achieved by leveraging virtual memory hardware, and efficient data structures for keeping track of which pages of memory were modified since the last update. Such extremely low-latency operations make Conversion well suited to a wide variety of concurrent applications. Below, in addition to a micro-benchmark and comparative evaluation, we retrofit Dthreads [28] with a Conversion-based memory model as a case study. This resulted in a speedup (up to 1.75x) for several benchmark programs and reduced the memory management code for Dthreads by 80%.",EuroSys '13: Proceedings of the 8th ACM European Conference on Computer Systems,clojure,http://dl.acm.org/ft_gateway.cfm?id=2465365&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
09-Clarke-A,2009,"Dave Clarke, Ilya Sergey",A semantics for context-oriented programming with layers,"Context-oriented programming (COP) is a new programming approach whereby the context in which expressions evaluate can be adapted as a program runs. COP provides a degree of flexibility beyond object-oriented programming, while arguably retaining more modularity and structure than aspect-oriented programming. Although many languages exploring the context-oriented approach exist, to our knowledge no formal type-sound dynamic semantics of these languages exists. We address this shortcoming by providing a concise syntax-based formal semantics for context-oriented programming with layers, as witnessed by ContextL, ContextJ*, and other languages. Our language is based on Featherweight Java extended with layers and scoped layer activation and deactivation. As layers may introduce methods not appearing in classes, we also give a static type system that ensures that no program gets stuck (i.e., there exists a binding for each dispatched method call).",COP '09: International Workshop on Context-Oriented Programming,clojure,http://dl.acm.org/ft_gateway.cfm?id=1562122&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
12-Koster-Domains:,2012,"Joeri De Koster, Tom Van Cutsem, Theo D'Hondt",Domains: safe sharing among actors,"The actor model has already proven itself as an interesting concurrency model that avoids issues such as deadlocks and race conditions by construction, and thus facilitates concurrent programming. While it has mainly been used in a distributed context it is certainly equally useful for modeling interactive components in a concurrent setting. In component based software, the actor model lends itself to naturally dividing the components over different actors and using message passing concurrency for implementing the interactivity between these components. The tradeoff is that the actor model sacrifices expressiveness and efficiency especially with respect to parallel access to shared state. This paper gives an overview of the disadvantages of the actor model in the case of shared state and then formulates an extension of the actor model to solve these issues. Our solution proposes domains and synchronization views to solve the issues without compromising on the semantic properties of the actor model. Thus, the resulting concurrency model maintains deadlock-freedom and avoids low-level race conditions.","AGERE! '12: Proceedings of the 2nd edition on Programming systems, languages and applications based on actors, agents, and decentralized control abstractions",clojure,http://dl.acm.org/ft_gateway.cfm?id=2414644&type=pdf&coll=DL&dl=ACM&CFID=399869229&CFTOKEN=28751441
