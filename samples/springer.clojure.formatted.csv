id,year,author,title,abstract,library,search_term,url
10-Kułakowski-cljRobust,2010,Konrad Kułakowski,cljRobust - Clojure Programming API for Lego Mindstorms NXT,"This paper presents the cljRobust - middleware library, which allows an intelligent control application to be written for Lego Mindstorms NXT. cljRobust is based on Clojure, which is a modern, concurrent dialect of the Lisp language. It shortens the distance between deliberative, symbolic processing and hardware. In this way, cljRobust facilitates the writing of control algorithms which operate close to the hardware layer, and thus are able to quickly respond to changes in the environment. Since Lego robots have been adopted by many leading academic centers all over the world as a standard tool for teaching robotics, the author hopes the cljRobust library may also be found as an interesting teaching aid in AI robotics.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-13541-5_6
12-Menarini-Dynamic,2012,Ingolf KrügerBarry DemchakMassimiliano Menarini,Dynamic Service Composition and Deployment with OpenRichServices,"We present OpenRichServices (ORS) as an Architecture Definition Language (ADL) for the compositional specification, deployment, and reconfiguration of systems of services. Key distinguishing features of ORS are its treatment of services as first-class citizens of the language, a clean separation between application and infrastructure flows to address cross-cutting concerns at the architectural level, and dynamic service binding to facilitate service instantiation, distributed deployment and reconfiguration. ORS specifications are executable – they can be deployed together with an ORS runtime system, and then coordinate the interactions between subsystems. To evaluate ORS, we developed an implementation of our ADL as a Domain Specific Language (DSL) using the JVM-based Clojure programming language; this allows us to leverage Clojure’s lock-free concurrency, high-performance immutable data structures, and dynamic binding capabilities. We compare the ORS ADL and its capabilities with Darwin, Wright, Rapide and SADL using a case study drawn from a mobile sensing platform.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-30835-2_9
11-Pergl-Modelling,2011,Robert Pergl,Modelling and Prototyping of Business Applications Based on Multilevel Domain-Specific Language,"An effective approach to modelling and prototyping of business applications is presented in this paper. The approach is based on three concepts: The concept of data structure abstraction, the concept of a behavioural model based on the dynamic functional approach and a design approach based on creating multiple levels of a domain-specific language. The characteristics of each concept are presented. A technique how to combine them together to create highly detailed descriptive models that may be easily turned to prototypes is shown and demonstrated. Limitations are formulated and benefits over the object-oriented approach are discussed, as well.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-24175-8_13
13-Horn-Model,2013,Tassilo Horn,Model Querying with FunnyQT,"FunnyQT is a new model querying and transformation approach. It is designed as an extensible API in the functional, JVM-based Lisp dialect Clojure. FunnyQT targets the modeling frameworks JGraLab and EMF, and it is extensible to other frameworks as well. Its querying parts are already stable while its transformation parts are still in early stages of development, so this paper focuses on the former.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-38883-5_7
12-Hotz-Verwendung,2012,Christian BetzLothar Hotz,Verwendung von Lisp in KI-Projekten,"In diesem Beitrag werden anhand von anwendungsorientierten Forschungsprototypen aus den Bereichen Konfigurierung, Diagnose und Szeneninterpretation wesentliche Lisp-Merkmale vorgestellt. Weiterhin wird ausgehend von den gemachten Erfahrungen eine Brücke zu aktuellen Entwicklungen aus dem Bereich der funktionalen Programmiersprachen geschlagen.",springer,clojure,http://link.springer.com/article/10.1007/s13218-011-0150-7
13-Rybola-Towards,2013,Robert PerglTiago Prince SalesZdeněk Rybola,Towards OntoUML for Software Engineering: From Domain Ontology to Implementation Model,"OntoUML is a promising method for ontological modelling. In this paper, we discuss its possible use for software engineering. We propose a method of transformation of an ontological model into a software-engineering object-oriented class model in UML and its instantiation. Our approach is based on the following best practices: pure object-oriented paradigm and approach of dividing state and identity as introduced in the Clojure programming language.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-41366-7_21
12-D’Hondt-Identifying,2012,Stefan MarrTheo D’Hondt,Identifying a Unifying Mechanism for the Implementation of Concurrency Abstractions on Multi-language Virtual Machines,"Supporting all known abstractions for concurrent and parallel programming in a virtual machines (VM) is a futile undertaking, but it is required to give programmers appropriate tools and performance. Instead of supporting all abstractions directly, VMs need a unifying mechanism similar to INVOKEDYNAMIC for JVMs.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-30561-0_13
10-Matyasik-RobustHX,2010,Konrad KułakowskiPiotr Matyasik,RobustHX - The Robust Middleware Library for Hexor Robots,"This paper presents RobustHX - an extension of the Robust middleware library, which allows the six-legged Hexor robot to be programmed in Java. Like Lego Mindstorms NXT robots, Hexor has been adopted by many academic centers in Poland as a tool for teaching AI robotics. For this reason, the authors hope that RobustHX may also be found as an interesting teaching aid allowing basic robotic experiments to be carried out.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-17319-6_24
12-Szmuc-Modeling,2012,Konrad KułakowskiTomasz Szmuc,Modeling Robot Behavior with CCL,"This paper presents the use of a Concurrent Communicating Lists (CCL) library in robot behavior modeling. CCL provides several software components, which allow the model to be built, simulated and formally verified. Due to the integration with the Robust library the CCL models can be deployed and executed on the actual hardware platforms. Besides the modeling robot behavior, the work also addresses the problem of modeling a robots environment.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-34327-8_7
10-Poetzsch-Heffter-JCoBox:,2010,Jan SchäferArnd Poetzsch-Heffter,JCoBox: Generalizing Active Objects to Concurrent Components,"Concurrency in object-oriented languages is still waiting for a satisfactory solution. For many application areas, standard mechanisms like threads and locks are too low level and have shown to be error-prone and not modular enough. Lately the actor paradigm has regained attention as a possible solution to concurrency in OOLs.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-14107-2_13
13-Clerc-OCaml-Java:,2013,Xavier Clerc,OCaml-Java: OCaml on the JVM,"This article presents the OCaml-Java project whose goal is to allow compilation of OCaml sources into Java bytecodes. The ability to run OCaml code on a Java virtual machine provides the developer with means to leverage the strengths of the Java ecosystem lacking in the OCaml world. Most notably, this includes access to a great number of libraries, and foundations for shared-memory concurrent programming. In order to achieve this, the OCaml-Java project does three contributions: (i) an optimized compiler and runtime support to achieve acceptable performance, (ii) an extension of the classical OCaml typer to allow manipulation of Java elements from the OCaml world, and (iii) a library dedicated to concurrent programming.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-40447-4_11
12-Vinoski-Programming,2012,Debasish GhoshJustin SheehyKresten Krab ThorupSteve Vinoski,Programming language impact on the development of distributed systems,"Programming languages have long impacted the development of distributed systems. While much middleware and distributed systems code continues to be developed today using mainstream languages such as Java and C++, several forces have recently combined to drive a renewed interest in other programming languages. The result of these forces has been an increase in the use of programming languages such as Erlang, Scala, Haskell, and Clojure that allow programming at a higher level of abstraction affording better modularity, enhanced speed of development, and added power of reasoning about systems being developed. Such languages can also be used to develop embedded domain specific languages that can expressively and succinctly model issues inherent in distributed systems including concurrency, parallelism, and fault tolerance. In this paper, we first present a history of programming languages and distributed systems, and then explore several alternative languages along with modern systems built using them. We focus on language and application features, how problems of distribution are addressed, concurrency issues, code brevity, extensibility, and maintenance concerns. Finally, we speculate about the possible influences today’s alternative programming languages could have on the future of middleware and distributed systems development.",springer,clojure,http://link.springer.com/article/10.1007/s13174-011-0042-y
10-Mens-Predicated,2010,Jorge VallejosSebastián GonzálezPascal CostanzaWolfgang De MeuterTheo D’HondtKim Mens,Predicated Generic Functions,"This paper presents predicated generic functions, a novel programming language abstraction that allows the expression of context-dependent behaviour in a declarative and modular manner, providing fine-grained control of method applicability and method specificity. Methods are guarded by predicates with user-defined orderings, thereby increasing the expressiveness of existing method dispatching approaches. We have prototyped our proposal in Lambic, an extension of the standard Common Lisp Object System. We illustrate and motivate our approach by discussing the implementation of a collaborative graphical editor.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-14046-4_5
09-Hübner-Lisp,2009,Didier VernaCharlotte HerzeelChristophe RhodesHans Hübner,Lisp,"This report covers the activities of the 5th European Lisp and Scheme Workshop. We introduce the motivation for a workshop focusing on languages in the Lisp family, and mention relevant organizational aspects. We summarize the presentations and discussions, including Mark Tarver and Rich Hickey’s keynote talks, and provide pointers to related work and events.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-02047-6_1
12-Shapiro-Visually,2012,Daniel R. SchlegelStuart C. Shapiro,"Visually Interacting with a Knowledge Base Using Frames, Logic, and Propositional Graphs","The knowledge base of a knowledge representation and reasoning system can simultaneously be thought of as being logic-, frame-, and graph-based. We present a method for naturally extending this three-fold view to methods for visual interaction with the knowledge base in the context of SNePS 3 and its newly developed user interface. Addition to, and querying of, the knowledge base are tasks well suited to a frame or logical representation. Visualization and exploration on the other hand are best done through the use of propositional graphs. We show how these interaction techniques, which are extensions of the underlying knowledge base representation, augment each other to allow users to manipulate and view large knowledge bases.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-29449-5_8
12-Wojciechowski-Typed,2012,Paweł T. Wojciechowski,Typed First-Class Communication Channels and Mobility for Concurrent Scripting Languages,"In the 1990s, there was considerable interest in mobile computation: systems in which running computations (or mobile agents) could be moved from one machine to another. Much of this work was in terms of high-level programming languages and mobile process calculi. An example is Nomadic Pict—a prototype high-level programming language in which to express and verify overlay networks, for reliable communication between mobile agents. One can ask whether the language abstractions could be useful for scripting programming in modern distributed deployment platforms, such as many-core processors, grids, web servers and datacentres. In this paper, we demonstrate selected features of Nomadic Pict, and show the use of typed channels and agent mobility for programming in the grid. We demonstrate example design patterns that can be used for implementing safe message passing, test & send, system bootstrapping, and relocatable computation.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-28830-2_22
10-Cader-Protrace:,2010,Konrad GrzanekAndrzej Cader,Protrace: Effective Recursion Tracing and Debugging Library for Functional Programming Style in Common Lisp,Among programming styles the functional one has gained an increasing attention in the recent years. Lisp dialects and Common Lisp in particular have always been languages of choice for artificial intelligence systems implementation. Debugging functional algorithms based in the natural way on recursion and immutability is especially hard. This article presents a library that allows the programmer to mark and trace Common Lisp expressions evaluation.,springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-13232-2_57
12-Purvis-Augmenting,2012,Christopher FrantzMariusz NowostawskiMartin K. Purvis,Augmenting Android with AOSE Principles for Enhanced Functionality Reuse in Mobile Applications,The Android platform has popularized and caused a widespread adoption of its application development approach based on loosely coupled application components. This loose coupling allows for a flexible composition of applications but also enables invocations and reuse of individual components from third-party applications.,springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-27216-5_13
10-Villa-Bridging,2010,Ferdinando Villa,Bridging Scales and Paradigms in Natural Systems Modeling,"I present a new modeling formalism that enables multiple-scale, multiple-paradigm, and modular modeling. The formalism starts with a generalization of the semantics of scientific observations, where specialized observation classes compute their states by running models, using the states of the dependent observations as input, inheriting, intersecting and harmonizing their topologies of time and space. This formalism, called semantic meta-modeling, offers a uniform and cohesive approach that encompasses data management, storage, querying and many aspects of traditional modeling. I will show how simple, elegant model specifications can be rewritten into queries that can be run on a semantic database to produce semantically annotated model results. The algorithm automatically operates context translation, matching probabilistic with deterministic data and models, performing data-driven structural transformations of model structure as required by the context, and seamlessly mixing traditionally isolated paradigms such as agent-based with process-based or temporally- with spatially-explicit.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-16552-8_1
13-Ierusalimschy-LuaRocks,2013,Hisham MuhammadFabio MascarenhasRoberto Ierusalimschy,LuaRocks - A Declarative and Extensible Package Management System for Lua,"While sometimes dismissed as an operating systems issue, or even a matter of systems administration, module management is deeply linked to programming language design. The main issues are how to instruct the build and runtime environments to find modules and handle their dependencies; how to package modules into redistributable units; how to manage interaction of code written in different languages; and how to map modules to files. These issues are either handled by the language itself or delegated to external tools. Language-specific package managers have risen as a solution to these problems, as they can perform module management portably and in a manner suited to the overall design of the language. This paper presents LuaRocks, a package manager for Lua modules. LuaRocks adopts a declarative approach for specifications using Lua itself as a description language and features an extensible build system that copes with the heterogeneity of the Lua ecosystem.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-40922-6_2
10-Kestler-A,2010,Johann M KrausHans A Kestler,A highly efficient multi-core algorithm for clustering extremely large datasets,"In recent years, the demand for computational power in computational biology has increased due to rapidly growing data sets from microarray and other high-throughput technologies. This demand is likely to increase. Standard algorithms for analyzing data, such as cluster algorithms, need to be parallelized for fast processing. Unfortunately, most approaches for parallelizing algorithms largely rely on network communication protocols connecting and requiring multiple computers. One answer to this problem is to utilize the intrinsic capabilities in current multi-core hardware to distribute the tasks among the different cores of one computer.",springer,clojure,http://link.springer.com/article/10.1186/1471-2105-11-169
12-Katayama-Sharing,2012,Pjotr PrinsNaohisa GotoAndrew YatesLaurent GautierScooter WillisChristopher FieldsToshiaki Katayama,Sharing Programming Resources Between Bio* Projects Through Remote Procedure Call and Native Call Stack Strategies,"Open-source software (OSS) encourages computer programmers to reuse software components written by others. In evolutionary bioinformatics, OSS comes in a broad range of programming languages, including C/C++, Perl, Python, Ruby, Java, and R. To avoid writing the same functionality multiple times for different languages, it is possible to share components by bridging computer languages and Bio* projects, such as BioPerl, Biopython, BioRuby, BioJava, and R/Bioconductor. In this chapter, we compare the two principal approaches for sharing software between different programming languages: either by remote procedure call (RPC) or by sharing a local call stack. RPC provides a language-independent protocol over a network interface; examples are RSOAP and Rserve. The local call stack provides a between-language mapping not over the network interface, but directly in computer memory; examples are R bindings, RPy, and languages sharing the Java Virtual Machine stack. This functionality provides strategies for sharing of software between Bio* projects, which can be exploited more often. Here, we present cross-language examples for sequence translation, and measure throughput of the different options. We compare calling into R through native R, RSOAP, Rserve, and RPy interfaces, with the performance of native BioPerl, Biopython, BioJava, and BioRuby implementations, and with call stack bindings to BioJava and the European Molecular Biology Open Software Suite. In general, call stack approaches outperform native Bio* implementations and these, in turn, outperform RPC-based approaches. To test and compare strategies, we provide a downloadable BioNode image with all examples, tools, and libraries included. The BioNode image can be run on VirtualBox-supported operating systems, including Windows, OSX, and Linux.",springer,clojure,http://link.springer.com/protocol/10.1007/978-1-61779-585-5_21
13-Bono-Eliciting,2013,Pierre GrenonBernard de Bono,Eliciting candidate anatomical routes for protein interactions: a scenario from endocrine physiology,"In this paper, we use: i) formalised anatomical knowledge of connectivity between body structures and ii) a formal theory of physiological transport between fluid compartments in order to define and make explicit the routes followed by proteins to a site of interaction. The underlying processes are the objects of mathematical models of physiology and, therefore, the motivation for the approach can be understood as using knowledge representation and reasoning methods to propose concrete candidate routes corresponding to correlations between variables in mathematical models of physiology. In so doing, the approach projects physiology models onto a representation of the anatomical and physiological reality which underpins them.",springer,clojure,http://link.springer.com/article/10.1186/1471-2105-14-131
11-Wickham-Mutable,2011,Hadley Wickham,Mutable objects in R,"Programming paradigms help us understand the differences and similarities between fundamental choices in language design. This paper looks at R in the context of three paradigms of object oriented programming: mutable versus immutable objects, generic-function versus message-passing methods, and class-based versus prototype-based inheritance. The paper also describes a new OO package for R, mutatr, which provides mutable objects with message-passing methods and prototype-based inheritance. The mutatr package is available on CRAN.",springer,clojure,http://link.springer.com/article/10.1007/s00180-011-0235-7
10-Herlihy-Transactional,2010,Maurice Herlihy,Transactional Memory Today,"The term “Transactional Memory” was coined back in 1993, but even today, there is a vigorous debate about what it means and what it should do. This debate sometimes generates more heat than light: terms are not always well-defined and criteria for making judgments are not always clear.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-11659-9_1
13-Nilsson-Haskell,2013,Bas van GijzelHenrik Nilsson,Haskell Gets Argumentative,"Argumentation theory is an interdisciplinary field studying how conclusions can be reached through logical reasoning. The notion of argument is completely general, including for example legal arguments, scientific arguments, and political arguments. Computational argumentation theory is studied in the context of artificial intelligence, and a number of computational argumentation frameworks have been put forward to date. However, there is a lack of concrete, high level realisations of these frameworks, which hampers research and applications at a number of levels. We hypothesise that the lack of suitable domain-specific languages in which to formalise argumentation frameworks is a contributing factor. In this paper, we present a formalisation of a particular computational argumentation framework, Carneades, as a case study with a view to investigate the extent to which functional languages are useful as a means to realising computational argumentation frameworks and reason about them.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-40447-4_14
11-Graffi-Programming,2011,Christian ScheidelerKalman Graffi,Programming for Distributed Computing: From Physical to Logical Networks,"The first programming languages predate computers and were mostly used as a form of mathematical reasoning. With the advent of modern electronic computers, programming languages became prominent as tools to specify and control the behaviour of these machines. A programming language is an artificial language that makes use of the functions that can be performed by a machine and allows one to express algorithms precisely. Early languages (see Chap. 4) were Fortran (1957) and Algol (1958), which were used for numerical computations. Cobol was issued in 1962 and optimized for business applications. Many other influential languages emerged from the late 1960s to the late 1970s, among them Simula (which introduced object-oriented programming), C, Smalltalk, Prolog (the first logic programming language) and ML (realizing a polymorphic type system on top of Lisp). Each of these languages spawned an entire family of descendants, and most modern languages count at least one of them in their ancestry.",springer,clojure,http://link.springer.com/chapter/10.1007/978-1-4614-1168-0_9
13-White-Notions,2013,Graham White,Notions of Information: Remarks on Fresco’s Paper,"We compare Fresco’s analysis of the Turing machine-based notion of computation with that of others, in particular with functional programming and with the reversible computing paradigm of Toffoli and others. We conclude that, although much useful philosophical work can be done by the sort of analysis that Fresco proposes, there is, nevertheless, always likely to be a number of individually viable but different accounts of computation.",springer,clojure,http://link.springer.com/article/10.1007/s13347-012-0073-8
12-Hofstedt-Die,2012,Petra Hofstedt,Die Evolution der Programmiersprachen der KI,"Neben Prolog und Lisp als wichtigste historische Repräsentanten der Programmiersprachen der Künstlichen Intelligenz hat sich mit der Entwicklung neuer Schwerpunkte innerhalb der KI auch ein breites Spektrum an KI-Sprachen herausgebildet, darunter constraint-basierte Sprachen, Multiparadigmen-Sprachen, die Sprachen des Semantic Web, Planungssprachen, Agentensprachen, und Sprachen zum Einsatz in der Robotik. Wir skizzieren in diesem Übersichtsartikel einen Ausschnitt der historischen Entwicklung und geben eine Einführung für diesen Themenschwerpunkt.",springer,clojure,http://link.springer.com/article/10.1007/s13218-011-0157-0
13-Gonder-TESS,2013,Matthew W. MitchellBrian RowePaul R. Sesink CleeMary Katherine Gonder,TESS Ad-Mixer: A novel program for visualizing TESS Q matrices,"TESS Ad-Mixer (available at http://www.albany.edu/faculty/gonder/Lab/index.html), is a Windows program we developed to display spatial interpolations of Q matrices generated by the program TESS. TESS Ad-Mixer provides an easy way to create two-dimensional representation of the Q matrices for two or more genetic clusters. The program uses a pixel based, vector algorithm that allows the user to specify a color scheme. The program generates spatially accurate, high-resolution files that are ideal for data display.",springer,clojure,http://link.springer.com/article/10.1007/s12686-013-9987-4
13-Niccolini-Scaling,2013,Davide SimoncelliMaurizio DusiFrancesco GringoliSaverio Niccolini,Scaling Out the Performance of Service Monitoring Applications with BlockMon,"To cope with real-time data analysis as the amount of data being exchanged over the network increases, an idea is to re-design algorithms originally implemented on the monitoring probe to work in a distributed manner over a stream-processing platform. In this paper we show preliminary performance analysis of a Twitter trending algorithm when running over BlockMon, an open-source monitoring platform which we extended to run distributed data-analytics algorithms: we show that it performs up to 23.5x and 34.2x faster on BlockMon than on Storm and Apache S4 respectively, two emerging stream-processing platforms.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-36516-4_26
12-Blair-Guest,2012,Valérie IssarnyGordon Blair,Guest editorial: Special issue on the future of middleware,,springer,clojure,http://link.springer.com/article/10.1007/s13174-011-0058-3
11-Sipper-Finch:,2011,Michael OrlovMoshe Sipper,Finch: A System for Evolving Java (Bytecode),"The established approach in genetic programming (GP) involves the definition of functions and terminals appropriate to the problem at hand, after which evolution of expressions using these definitions takes place. We have recently developed a system, dubbed FINCH (Fertile Darwinian Bytecode Harvester), to evolutionarily improve actual, extant software, which was not intentionally written for the purpose of serving as a GP representation in particular, nor for evolution in general. This is in contrast to existing work that uses restricted subsets of the Java bytecode instruction set as a representation language for individuals in genetic programming. The ability to evolve Java programs will hopefully lead to a valuable new tool in the software engineer’s toolkit.",springer,clojure,http://link.springer.com/chapter/10.1007/978-1-4419-7747-2_1
13-Clerc-OCaml-Java:,2013,Xavier Clerc,OCaml-Java: From OCaml Sources to Java Bytecodes,"This article presents the code generation scheme of the OCaml-Java compiler. The goal of the OCaml-Java project is to allow execution of OCaml programs on a Java Virtual Machine. In order to achieve decent performance, it is necessary to build a compiler producing optimized bytecode that will rely on an efficient support library at runtime.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-41582-1_5
12-Qin-A,2012,Granville BarnettShengchao Qin,A Composable Mixed Mode Concurrency Control Semantics for Transactional Programs,"Most software transactional memories employ optimistic concurrency control. A pessimistic semantics, however, is not without its benefits: its programming model is often much simpler to reason about and supports the execution of irreversible operations. We present a programming model that supports both optimistic and pessimistic concurrency control semantics. Our pessimistic transactions, guaranteed transactions (gatomics), afford a stronger semantics than that typically employed by pessimistic transactions by guaranteeing run once execution and safe encapsulation of the privatisation and publication idioms. We describe our mixed mode transactional programming language by giving a small step operational semantics. Using our semantics and their derived schedules of actions (reads and writes) we show that conflicting transactions (atomics) and gatomics are serialisable. We then go on to define schedules of actions in the form of Java’s memory model (JMM) and show that the same properties that held under our restrictive memory model also hold under our modified JMM.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-34281-3_6
13-Chen-A,2013,Yi-Hsing ChangJheng-Yu Chen,A Hybrid Cloud for Effective Retrieval from Public Cloud Services,"For a hybrid cloud, efficient identity authentication and services retrieval are the two most important issues. Therefore, this paper proposes an architecture for a hybrid cloud that solves these two problems. The services requiring a large amount of resources are designed to be intelligent agents and embedded into a private cloud for applications supported by the Google application engine (GAE). When the users acquire the services from the hybrid cloud, these intelligent agents efficiently authenticate the access rights and retrieve the required services for users.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-36546-1_7
11-Laddad-A,2011,Ramnivas Laddad,A Real-World Perspective of AOP,"What is the real deal with AOP? Is it something that you should embrace or ignore? What do you gain with AOP, and what do you risk by adopting it? Let’s address these important questions from a practitioner’s point of view. We’ll start with AOP in the context of the typical hype cycle. This will give us a historical perspective on AOP evolution and indicate what lies ahead. We also look at the landscape, focusing on the current situation and changes in last few years. While AOP is a more general concept, because our focus is the real world use of it, we’ll focus on AspectJ—its most prominent implementation.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-22031-9_3
12-Walker-CMQ,2012,Joerg FritschCoral Walker,"CMQ - A lightweight, asynchronous high-performance messaging queue for the cloud","In cloud computing environments guarantees, consistency mechanisms, (shared) state and transactions are frequently traded for robustness, scalability and performance. Based on this challenge we present CMQ, a UDP-based inherently asynchronous message queue to orchestrate messages, events and processes in the cloud. CMQ’s inherently asynchronous design is shown to perform especially well in modern Layer 2 switches in data center networks, as well as in the presence of errors. CMQ’s lightweight edge-to-edge design, which is somewhat similar to Unix Pipes, makes it very composable. By presenting our work, we hope to initiate discussion on how to implement lightweight messaging paradigms that are aligned with the overall architectures and goals of cloud computing.",springer,clojure,http://link.springer.com/article/10.1186/2192-113X-1-20
10-Taylor-An,2010,Ronald C Taylor,An overview of the Hadoop/MapReduce/HBase framework and its current applications in bioinformatics,"Bioinformatics researchers are now confronted with analysis of ultra large-scale data sets, a problem that will only increase at an alarming rate in coming years. Recent developments in open source software, that is, the Hadoop project and associated software, provide a foundation for scaling to petabyte scale data warehouses on Linux clusters, providing fault-tolerant parallelized analysis on such data using a programming style named MapReduce.",springer,clojure,http://link.springer.com/article/10.1186/1471-2105-11-S12-S1
13-Xhafa-Parallel,2013,Ciprian DobreFatos Xhafa,Parallel Programming Paradigms and Frameworks in Big Data Era,"With Cloud Computing emerging as a promising new approach for ad-hoc parallel data processing, major companies have started to integrate frameworks for parallel data processing in their product portfolio, making it easy for customers to access these services and to deploy their programs. We have entered the Era of Big Data. The explosion and profusion of available data in a wide range of application domains rise up new challenges and opportunities in a plethora of disciplines—ranging from science and engineering to biology and business. One major challenge is how to take advantage of the unprecedented scale of data—typically of heterogeneous nature—in order to acquire further insights and knowledge for improving the quality of the offered services. To exploit this new resource, we need to scale up and scale out both our infrastructures and standard techniques. Our society is already data-rich, but the question remains whether or not we have the conceptual tools to handle it. In this paper we discuss and analyze opportunities and challenges for efficient parallel data processing. Big Data is the next frontier for innovation, competition, and productivity, and many solutions continue to appear, partly supported by the considerable enthusiasm around the MapReduce paradigm for large-scale data analysis. We review various parallel and distributed programming paradigms, analyzing how they fit into the Big Data era, and present modern emerging paradigms and frameworks. To better support practitioners interesting in this domain, we end with an analysis of on-going research challenges towards the truly fourth generation data-intensive science.",springer,clojure,http://link.springer.com/article/10.1007/s10766-013-0272-7
12-Odersky-JavaScript,2012,Grzegorz KossakowskiNada AminTiark RompfMartin Odersky,JavaScript as an Embedded DSL,"Developing rich web applications requires mastering different environments on the client and server sides. While there is considerable choice on the server-side, the client-side is tied to JavaScript, which poses substantial software engineering challenges, such as moving or sharing pieces of code between the environments. We embed JavaScript as a DSL in Scala, using Lightweight Modular Staging. DSL code can be compiled to JavaScript or executed as part of the server application. We use features of the host language to make client-side programming safer and more convenient. We use gradual typing to interface typed DSL programs with existing JavaScript APIs. We exploit a selective CPS transform already available in the host language to provide a compelling abstraction over asynchronous callback-driven programming in our DSL.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-31057-7_19
11-Keidar-SMV:,2011,Dmitri PerelmanAnton ByshevskyOleg LitmanovichIdit Keidar,SMV: Selective Multi-Versioning STM,"We present Selective Multi-Versioning (SMV), a new STM that reduces the number of aborts, especially those of long read-only transactions. SMV keeps old object versions as long as they might be useful for some transaction to read. It is able to do so while still allowing reading transactions to be invisible by relying on automatic garbage collection to dispose of obsolete versions.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-24100-0_9
13-Stankovski-Experiences,2013,Dana PetcuBeniamino Di MartinoSalvatore VenticinqueMassimiliano RakTamás MáhrGorka Esnal LopezFabrice BritoRoberto CossuMiha StoparSvatopluk ŠperkaVlado Stankovski,Experiences in building a mOSAIC of clouds,"The diversity of Cloud computing services is challenging the application developers as various and non-standard interfaces are provided for these services. Few middleware solutions were developed until now to support the design, deployment and execution of service-independent applications as well as the management of resources from multiple Clouds. This paper focuses on one of these advanced middleware solutions, called mOSAIC. Written after the completion of its development, this paper presents an integrated overview of the mOSAIC approach and the use of its various software prototypes in a Cloud application development process. We are starting from the design concepts and arrive to various applications, as well as to the position versus similar initiatives.",springer,clojure,http://link.springer.com/article/10.1186/2192-113X-2-12
11-Engelschall-Pluggable,2011,Bernhard G. HummRalf S. Engelschall,Pluggable Programming Language Features for Incremental Code Quality Enhancement,"Evolutionary prototyping is an incremental software development method in which a proof of concept is, step by step, extended towards the final product. This article pleads for a programming approach termed “incremental code quality enhancement” when developing software incrementally. However, current programming languages are not well suited for incremental code quality enhancement. They are inflexible regarding their use of language features like typing, access control, contracts, etc. In some languages, the programmer is forced to use them, in others he may not. This article introduces pluggable programming language features, a concept that allows greater flexibility for application programmers without losing control over the use of those features. The approach is demonstrated exemplary by interface specifications for a business information system.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-23391-3_1
"13-Grossman-Java
",2013,Colin S. GordonWerner DietlMichael D. ErnstDan Grossman,"Java
              
                UI
              : Effects for Controlling UI Object Access","Most graphical user interface (GUI) libraries forbid accessing UI elements from threads other than the UI event loop thread. Violating this requirement leads to a program crash or an inconsistent UI. Unfortunately, such errors are all too common in GUI programs.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-39038-8_8
12-Cock-Introduction,2012,Jeroen JanssenSteven SchockaertDirk VermeirMartine de Cock,Introduction,"Language is one of the most important tools that exist. It allows humans to communicate efficiently and to transfer knowledge between generations. According to Benjamin Whorf, language even shapes views and influences thoughts. Unfortunately, while human language is useful for communication between humans, it is not as efficient for communicating with our modern day devices. Therefore, ever since the rise of computers, the need has grown for languages that enable us to tell these machines what we expect them to do. Such languages are called programming languages. Their foundations can be dated back to the 1800s, where Joseph Marie Jacquard used punched cards to encode cloth patterns for his textile machine, called the “Jacquard loom”. Charles Babbage improved on this idea when designing his “analytical engine” by allowing the machine to be reprogrammed using punched cards. Hence, instead of merely using the punched cards as data, the analytical engine could perform arbitrary computations that were encoded in the punched cards. As such, we can consider this the first real programmable machine",springer,clojure,http://link.springer.com/chapter/10.2991/978-94-91216-59-6_1
13-Leastar-Project,2013,Leigh GriffinPeter ElgerEamonn de Leastar,Project Zeppelin: A Modern Web Application Development Framework,"Application Platforms, by which we mean the programming languages, libraries, frameworks and associated run time support, are central to the modern development experience. They are often imbued with an ethos, value set and engineering approach that carries through the full lifecycle of the platform itself, steering its development and evolution through the various challenges - both technical and commercial - it must surmount in order to survive. Anecdotal evidence would suggest that these platforms have a lifespan of approximately 10 years - after which they enter a gradual decline. The reasons for this decline vary, including commercial shifts, new (or rediscovered) thinking and changes in the underlying technology. The authors believe that two of the major platforms in use today - J2EE and .NET - may be about to enter this declining phase. The major factors contributing to this decline; including considerable complexity, significant disjunction in the developer experience and major challenges in meeting the demands of the modern, predominantly mobile, social web. A new application platform, dubbed Zeppelin, architected to programatically meet the challenges of the Future Internet is presented.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-35887-6_10
13-Galas-RCytoscape:,2013,Paul T ShannonMark GrimesBurak KutluJan J BotDavid J Galas,RCytoscape: tools for exploratory network analysis,"Biomolecular pathways and networks are dynamic and complex, and the perturbations to them which cause disease are often multiple, heterogeneous and contingent. Pathway and network visualizations, rendered on a computer or published on paper, however, tend to be static, lacking in detail, and ill-equipped to explore the variety and quantities of data available today, and the complex causes we seek to understand.",springer,clojure,http://link.springer.com/article/10.1186/1471-2105-14-217
13-Wenzel-Shared-Memory,2013,Makarius Wenzel,Shared-Memory Multiprocessing for Interactive Theorem Proving,"We address the multicore problem for interactive theorem proving, notably for Isabelle. The stagnation of CPU clock frequency since 2005 means that hardware manufactures multiply cores to keep up with “Moore’s Law”, but this imposes the burden of explicit parallelism to application developers. To cope with this trend, Isabelle has started to support parallel theory and proof processing in 2007, and continuously improved the use of multicore hardware in recent years. This is of practical relevance to theory and proof development, since their size and complexity is roughly correlated with the real time required for re-checking. Scaling up the prover on parallel hardware will facilitate maintenance of larger theory libraries, for example.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-39634-2_30
13-Adl-Tabatabai-Software,2013,Victor PankratiusAli-Reza Adl-Tabatabai,Software Engineering with Transactional Memory Versus Locks in Practice,"Transactional Memory (TM) promises to simplify parallel programming by replacing locks with atomic transactions. Despite much recent progress in TM research, there is very little experience using TM to develop realistic parallel programs from scratch. In this article, we present the results of a detailed case study comparing teams of programmers developing a parallel program from scratch using transactional memory and locks. We analyze and quantify in a realistic environment the development time, programming progress, code metrics, programming patterns, and ease of code understanding for six teams who each wrote a parallel desktop search engine over a fifteen week period. Three randomly chosen teams used Intel’s Software Transactional Memory compiler and Pthreads, while the other teams used just Pthreads. Our analysis is exploratory: Given the same requirements, how far did each team get? The TM teams were among the first to have a prototype parallel search engine. Compared to the locks teams, the TM teams spent less than half the time debugging segmentation faults, but had more problems tuning performance and implementing queries. Code inspections with industry experts revealed that TM code was easier to understand than locks code, because the locks teams used many locks (up to thousands) to improve performance. Learning from each team’s individual success and failure story, this article provides valuable lessons for improving TM.",springer,clojure,http://link.springer.com/article/10.1007/s00224-013-9452-5
10-Morazán-Trends,2010,Peter AchtenMarko van EekelenPieter KoopmanMarco T. Morazán,Trends in Trends in Functional Programming 1999/2000 versus 2007/2008,"The Trends in Functional Programming Symposia are an annual event dedicated to promoting new research directions in functional programming and to investigating the relationship between functional programming and other branches of Computer Science. The TFP series started in 1999 and the 2008 meeting marked the first decade of the symposium. In this paper we identify and discuss the trends presented at TFP using a macro-vision lens that looks at topics in the first two volumes of TFP and the two most recent volumes of TFP. The goal is to calibrate how trends have changed over a decade instead of analyzing trends with a micro-vision lens that focuses on changes from year to year. The major trends identified are work on parallel functional programming, types, formal verification, implementation of functional languages, and application development.",springer,clojure,http://link.springer.com/article/10.1007/s10990-011-9074-z
12-Sestoft-Real-World,2012,Peter Sestoft,Real-World Abstract Machines,This chapter discusses some widely used real-world abstract machines.,springer,clojure,http://link.springer.com/chapter/10.1007/978-1-4471-4156-3_9
12-Paralič-Investigation,2012,František BabičJozef WagnerJán Paralič,Investigation of Performed User Activities in Overall Context with IT Analytical Framework,"Collaborative user activities represent an important source of knowledge and experiences that can be identified with suitable discovery methods. These activities are typically realized within collaborative environments which in several cases offer only a simple analytical module providing basic statistical information. However, these results are not sufficient for deeper understanding of performed activities, processes behind realized actions, hidden relations, etc. A motivation to discover and understand such knowledge from user activities led us to design a formal representation of historical events and method for their advanced analysis. This paper describes and evaluates a semi-automatic procedure of pattern definition and discovery that can assist and simplify manual evaluation of collected data by teachers, researchers or evaluators.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-30359-3_25
10-Gautier-An,2010,Laurent Gautier,An intuitive Python interface for Bioconductor libraries demonstrates the utility of language translators,"Computer languages can be domain-related, and in the case of multidisciplinary projects, knowledge of several languages will be needed in order to quickly implements ideas. Moreover, each computer language has relative strong points, making some languages better suited than others for a given task to be implemented. The Bioconductor project, based on the R language, has become a reference for the numerical processing and statistical analysis of data coming from high-throughput biological assays, providing a rich selection of methods and algorithms to the research community. At the same time, Python has matured as a rich and reliable language for the agile development of prototypes or final implementations, as well as for handling large data sets.",springer,clojure,http://link.springer.com/article/10.1186/1471-2105-11-S12-S11
12-Binder-Node.Scala:,2012,Daniele BonettaDanilo AnsaloniAchille PeternierCesare PautassoWalter Binder,Node.Scala: Implicit Parallel Programming for High-Performance Web Services,"Event-driven programming frameworks such as Node.JS have recently emerged as a promising option for Web service development. Such frameworks feature a simple programming model with implicit parallelism and asynchronous I/O. The benefits of the event-based programming model in terms of concurrency management need to be balanced against its limitations in terms of scalability on multicore architectures and against the impossibility of sharing a common memory space between multiple Node.JS processes. In this paper we present Node.Scala, an event-based programming framework for the JVM which overcomes the limitations of current event-driven frameworks. Node.Scala introduces safe stateful programming for event-based services. The programming model of Node.Scala allows threads to safely share state in a standard event-based programming model. The runtime system of Node.Scala automatically parallelizes and synchronizes state access to guarantee correctness. Experiments show that services developed in Node.Scala yield linear scalability and high throughput when deployed on multicore machines.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-32820-6_62
12-Chen-A,2012,Barna L. BihariMichael WongAmy WangBronis R. de SupinskiWang Chen,A Case for Including Transactions in OpenMP II: Hardware Transactional Memory,"We present recent results using Hardware Transactional Memory (HTM) on IBM’s Blue Gene/Q system. By showing how this latest TM system can significantly reduce the complexity of shared memory programming while retaining efficiency, we continue to make our case that the OpenMP language specification should include transactional language constructs. Furthermore, we argue for its support as an advanced abstraction to support mutable shared state, thus expanding OpenMP synchronization capabilities. Our results demonstrate how TM can be used to simplify modular parallel programming in OpenMP while maintaining parallel performance. We show performance advantages in the BUSTM (Benchmark for UnStructured-mesh Transactional Memory) model using the transactional memory hardware implementation on Blue Gene/Q.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-30961-8_4
13-Spector-Evolving,2013,Thomas HelmuthLee Spector,Evolving SQL Queries from Examples with Developmental Genetic Programming,"Large databases are becoming ever more ubiquitous, as are the opportunities for discovering useful knowledge within them. Evolutionary computation methods such as genetic programming have previously been applied to several aspects of the problem of discovering knowledge in databases. The more specific task of producing human-comprehensible SQL queries has several potential applications but has thus far been explored only to a limited extent. In this chapter we show howdevelopmental genetic programming can automatically generate SQL queries from sets of positive and negative examples. We show that a developmental genetic programming system can produce queries that are reasonably accurate while excelling in human comprehensibility relative to the well-known C5.0 decision tree generation system.",springer,clojure,http://link.springer.com/chapter/10.1007/978-1-4614-6846-2_1
11-Herlihy-Transactional,2011,Maurice Herlihy,Transactional Memories,,springer,clojure,http://link.springer.com/referenceworkentry/10.1007/978-0-387-09766-4_122
11-Helmuth-What’s,2011,Lee SpectorKyle HarringtonBrian MartinThomas Helmuth,What’s in an Evolved Name? The Evolution of Modularity via Tag-Based Reference,"Programming languages provide a variety of mechanisms to associate names with values, and these mechanisms play a central role in programming practice. For example, they allow multiple references to the same storage location or function in different parts of a complex program. By contrast, the representations used in current genetic programming systems provide few if any naming mechanisms, and it is therefore generally not possible for evolved programs to use names in sophisticated ways. In this chapter we describe a new approach to names in genetic programming that is based on Holland’s concept of tags. We demonstrate the use of tag-based names, we describe some of the ways in which they may help to extend the power and reach of genetic programming systems, and we look at the ways that tag-based names are actually used in an evolved program that solves a robot navigation problem.",springer,clojure,http://link.springer.com/chapter/10.1007/978-1-4614-1770-5_1
12-Grzanek-Software,2012,Konrad Grzanek,Software Modeling Language with Frames and Multi-abstractions: An Overview,"Static software analyzers should be able to work on an uniform software models and run uniformly implemented algorithms that would crosscut the borders of implementation platforms. We present an overview of an universal software modeling language capable of covering the semantic constructs that can be found both in object and functional programming style. Concrete and abstract elements of the language are being discussed together with the frame-based binding mechanism. We also give some insight into the implementation details, namely the persistence layer and the proper type hierarchies.",springer,clojure,http://link.springer.com/chapter/10.1007/978-3-642-29350-4_67
10-Esteban-How,2010,Javier García GuzmánJavier Saldaña RamosAntonio Amescua SecoAna Sanz Esteban,How to get mature global virtual teams: a framework to improve team process management in distributed software teams,"Managing global software development teams is not an easy task because of the additional problems and complexities that have to be taken into account. This paper defines VTManager, a methodology that provides a set of efficient practices for global virtual team management in software development projects. These practices integrate software development techniques in global environments with others such as explicit practices for global virtual team management, definition of skills and abilities needed to work in these teams, availability of collaborative work environments and shared knowledge management practices. The results obtained and the lessons learned from implementing VTManager in a pilot project to develop software tools for collaborative work in rural environments are also presented. This project was carried out by geographically distributed teams involving people from seven countries with a high level of virtualness.",springer,clojure,http://link.springer.com/article/10.1007/s11219-010-9096-5
